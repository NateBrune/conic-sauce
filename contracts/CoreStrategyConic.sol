// SPDX-License-Identifier: AGPL-3.0
// Feel free to change the license, but this is what we use

pragma solidity ^0.8.17;
pragma experimental ABIEncoderV2;

// These are the core Yearn libraries
import {BaseStrategy, StrategyParams} from "@yearnvaults/contracts/BaseStrategy.sol";
import {SafeERC20, IERC20, Address} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {SafeMath} from "@openzeppelin/contracts/utils/math/SafeMath.sol";
import "interfaces/IConicPool.sol";
import "interfaces/ILpTokenStaker.sol";
import "interfaces/IRewardManager.sol";
import "interfaces/ICurveFi.sol";

struct CoreStrategyConicConfig {
    /*****************************/
    /*             Farm           */
    /*****************************/
    // Liquidity pool address for base <-> short tokens
    address conicPool;
    address conicLp;
    //address router;
    uint256 minDeploy;
}


contract CoreStrategyConic is BaseStrategy {
    event debug2(uint256);
    using SafeERC20 for IERC20;
    using Address for address;
    using SafeMath for uint256;
    using SafeMath for uint8;

    IERC20 public constant CVX = IERC20(0x4e3FBD56CD56c3e72c1403e103b45Db9da5B9D2B);
    IERC20 public constant CRV = IERC20(0xD533a949740bb3306d119CC777fa900bA034cd52);
    IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    IERC20 public constant CNC = IERC20(0x9aE380F0272E2162340a5bB646c354271c0F5cFC);
    IRewardManager public rewardsManager = IRewardManager(0xE976F643d4dc08Aa3CeD55b0CA391B1d11328347);
    ILpTokenStaker public lpTokenStaker = ILpTokenStaker(0xeC037423A61B634BFc490dcc215236349999ca3d);
    ICurveFi public cncPool = ICurveFi(0x838af967537350D2C44ABB8c010E49E32673ab94);
    ICurveFi public cvxPool = ICurveFi(0xB576491F1E6e5E62f1d8F26062Ee822B40B0E0d4); 
    ICurveFi public crvPool = ICurveFi(0x8301AE4fc9c624d1D396cbDAa1ed877821D7C511);
    IConicPool public conicPool;
    ILpToken public conicLp;
    //address public router;
    uint256 public minDeploy;
    //uint256 public wantDecimals;
    uint256 public slippageAdj = 9500; // 99%
    uint256 constant BASIS_PRECISION = 10000;

    constructor(address _vault, CoreStrategyConicConfig memory _config ) BaseStrategy(_vault) {
        //wantDecimals = want.decimals();
        conicPool = IConicPool(_config.conicPool);
        conicLp = ILpToken(_config.conicLp);
        //router  = _config.router;
        minDeploy = _config.minDeploy;
        _setup();
    }

    function _setup() internal virtual{}
    // TODO: INTERNAL
    function claimHarvest() public virtual{}
    //function _withdraw(uint256 _amount) internal virtual{}
    //TODO: MAKE THESE BAD BOYS INTERNAL
    function _withdraw(uint256 _amount) public virtual returns (uint256 _liquidatedAmount, uint256 _loss){}
    function _withdrawLp(uint256 _amount) public virtual{}

    function _deposit(uint256 _amount) public virtual{}
    function balancePendingHarvest() public view virtual returns (uint256){}
    // ******** OVERRIDE THESE METHODS FROM BASE CONTRACT ************

    function name() external view override returns (string memory) {
        // Add your own name here, suggestion e.g. "StrategyCreamYFI"
        return "StrategyConicOmni";
    }

    function countLpPooled() public view returns (uint256) {
        return lpTokenStaker.getUserBalanceForPool(address(conicPool), address(this));
    }
    
    function estimatedTotalAssets() public view override returns (uint256) {
        uint256 wantBal = want.balanceOf(address(this));
        return wantBal.add(_lpToWant(countLpPooled()));
    }

    function _priceConicLP() internal view returns (uint256){
        uint256 lpSupply = conicLp.totalSupply();
        uint256 underlying = conicPool.totalUnderlying();
        return uint256(lpSupply * (uint256(10) ** IERC20Metadata(address(want)).decimals())).div(underlying);
    }
    
    function _wantToLp(uint256 _amount) internal view returns (uint256) {
        uint256 price = _priceConicLP();
        return _amount.mul(price).div(uint256(10)**IERC20Metadata(address(want)).decimals());
    }
    
    function _lpToWant(uint256 _amount) internal view returns (uint256) {
        uint256 price = _priceConicLP();
        return _amount.mul(uint256(10) ** IERC20Metadata(address(want)).decimals()).div(price);
    }

    function _getTotalDebt() internal view returns (uint256) {
        return vault.strategies(address(this)).totalDebt;
    }

    function prepareReturn(uint256 _debtOutstanding)
        internal
        override
        returns (
            uint256 _profit,
            uint256 _loss,
            uint256 _debtPayment
        )
    {
        // TODO: Do stuff here to free up any returns back into `want`
        // NOTE: Return `_profit` which is value generated by all positions, priced in `want`
        // NOTE: Should try to free up at least `_debtOutstanding` of underlying position
        uint256 totalAssets = estimatedTotalAssets();
        uint256 totalDebt = _getTotalDebt();
        if (totalAssets > totalDebt) {
            _profit = totalAssets.sub(totalDebt);
            (uint256 amountFreed, ) = _withdraw(_debtOutstanding.add(_profit));
            if (_debtOutstanding > amountFreed) {
                _debtPayment = amountFreed;
                _profit = 0;
            } else {
                _debtPayment = _debtOutstanding;
                _profit = amountFreed.sub(_debtOutstanding);
            }
        } else {
            _withdraw(_debtOutstanding);
            _debtPayment = balanceOfWant();
            _loss = totalDebt.sub(totalAssets);
        }

        if (balancePendingHarvest() > 100) {
            _profit += _harvestInternal();
        }
    }

    function adjustPosition(uint256 _debtOutstanding) internal override {
        // TODO: Do something to invest excess `want` tokens (from the Vault) into your positions
        // NOTE: Try to adjust positions so that `_debtOutstanding` can be freed up on *next* harvest (not immediately)
        uint256 _wantAvailable = balanceOfWant();
        if (_debtOutstanding >= _wantAvailable) {
            return;
        }
        uint256 toInvest = _wantAvailable.sub(_debtOutstanding);

        if(toInvest > 0) {
            _deposit(toInvest);
        }
    }

    function liquidatePosition(uint256 _amountNeeded)
        internal
        override
        returns (uint256 _liquidatedAmount, uint256 _loss)
    {
        // TODO: Do stuff here to free up to `_amountNeeded` from all positions back into `want`
        // NOTE: Maintain invariant `want.balanceOf(this) >= _liquidatedAmount`
        // NOTE: Maintain invariant `_liquidatedAmount + _loss <= _amountNeeded`
        _withdraw(_amountNeeded);

        uint256 totalAssets = want.balanceOf(address(this));
        if (_amountNeeded > totalAssets) {
            _liquidatedAmount = totalAssets;
            unchecked {
                _loss = _amountNeeded - totalAssets;
            }
        } else {
            _liquidatedAmount = _amountNeeded;
        }
    }

    function liquidateAllPositions() internal override returns (uint256) {
        // TODO: Liquidate all positions and return the amount freed.
        _withdrawLp(countLpPooled());
        return want.balanceOf(address(this));
    }

    // NOTE: Can override `tendTrigger` and `harvestTrigger` if necessary

    function prepareMigration(address _newStrategy) internal override {
        // TODO: Transfer any non-`want` tokens to the new strategy
        // NOTE: `migrate` will automatically forward all `want` in this strategy to the new one
        liquidateAllPositions();
    }

    /// called by keeper to harvest rewards and either repay debt
    function _harvestInternal() internal returns (uint256 _wantHarvested) {
        uint256 wantBefore = balanceOfWant();
        /// harvest from farm & wantd on amt borrowed vs LP value either -> repay some debt or add to collateral
        //claimHarvest();
        //_sellHarvestWant();
        _wantHarvested = balanceOfWant().sub(wantBefore);
        return _wantHarvested;
    }

    function balanceOfWant() public view returns (uint256) {
        return (want.balanceOf(address(this)));
    }

    // Override this to add all tokens/tokenized positions this contract manages
    // on a *persistent* basis (e.g. not just for swapping back to want ephemerally)
    // NOTE: Do *not* include `want`, already included in `sweep` below
    //
    // Example:
    //
    //    function protectedTokens() internal override view returns (address[] memory) {
    //      address[] memory protected = new address[](3);
    //      protected[0] = tokenA;
    //      protected[1] = tokenB;
    //      protected[2] = tokenC;
    //      return protected;
    //    }
    function protectedTokens()
        internal
        view
        override
        returns (address[] memory)
    {}

    /**
     * @notice
     *  Provide an accurate conversion from `_amtInWei` (denominated in wei)
     *  to `want` (using the native decimal characteristics of `want`).
     * @dev
     *  Care must be taken when working with decimals to assure that the conversion
     *  is compatible. As an example:
     *
     *      given 1e17 wei (0.1 ETH) as input, and want is USDC (6 decimals),
     *      with USDC/ETH = 1800, this should give back 1800000000 (180 USDC)
     *
     * @param _amtInWei The amount (in wei/1e-18 ETH) to convert to `want`
     * @return The amount in `want` of `_amtInEth` converted to `want`
     **/
    function ethToWant(uint256 _amtInWei)
        public
        view
        virtual
        override
        returns (uint256)
    {
        // TODO create an accurate price oracle
        return _amtInWei;
    }
}
